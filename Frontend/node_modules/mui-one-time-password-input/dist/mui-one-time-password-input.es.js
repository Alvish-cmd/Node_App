import T from "react";
import L from "@mui/material/Box";
import { styled as W } from "@mui/material/styles";
import q from "@mui/material/TextField";
import { jsx as C } from "react/jsx-runtime";
const z = W(q)`
  input {
    text-align: center;
  }
`, G = {
  TextFieldStyled: z
}, H = (n) => /* @__PURE__ */ C(G.TextFieldStyled, {
  ...n
}), I = {
  left: "ArrowLeft",
  right: "ArrowRight",
  backspace: "Backspace"
};
function J(n, o) {
  return n <= 0 ? [] : Array.from({ length: n }, o);
}
function Q(n, o, l) {
  return n.map((a, i) => o === i ? l : a);
}
function w(n) {
  return n.join("");
}
function B(n, o) {
  return [...n, o];
}
function U(n, o, l) {
  return n.reduce(
    (a, i, f) => {
      const { characters: d, restArrayMerged: p } = a;
      if (f < l)
        return {
          restArrayMerged: p,
          characters: B(d, i)
        };
      const [h, ...g] = p;
      return {
        restArrayMerged: g,
        characters: B(d, h || "")
      };
    },
    {
      restArrayMerged: o,
      characters: []
    }
  ).characters;
}
function X(n) {
  return n.split("");
}
const Z = T.forwardRef((n, o) => {
  const {
    value: l,
    length: a,
    autoFocus: i,
    onChange: f,
    TextFieldsProps: d,
    onComplete: p,
    validateChar: h,
    className: g,
    ...P
  } = n, {
    onPaste: R,
    onFocus: S,
    onKeyDown: k,
    className: M,
    ...E
  } = d || {}, c = J(a, (e, r) => ({
    character: l[r] || "",
    inputRef: T.createRef()
  })), m = (e) => c.findIndex(({
    inputRef: r
  }) => r.current === e), D = () => c.map(({
    character: e
  }) => e), N = (e, r) => {
    const t = Q(D(), e, r);
    return w(t);
  }, x = (e) => {
    c[e]?.inputRef.current?.focus();
  }, u = (e) => {
    c[e]?.inputRef.current?.select();
  }, y = (e) => {
    e + 1 !== a && (c[e + 1].character ? u(e + 1) : x(e + 1));
  }, K = (e) => {
    e > 0 && u(e - 1);
  }, V = (e) => {
    const r = e.target.value[0] || "", t = m(e.target);
    if (typeof h == "function" && !h(r, t))
      return;
    const s = N(t, r);
    f?.(s), s.length === a && p?.(s), r !== "" ? s.length < a ? y(s.length - 1) : y(t) : s[t] ? u(t) : K(t);
  }, b = (e) => {
    e.preventDefault(), e.target.select(), S?.(e);
  }, j = (e) => {
    const r = e.target, t = m(r);
    r.value === e.key ? (e.preventDefault(), y(t)) : !r.value && I.backspace === e.key || I.left === e.key ? (e.preventDefault(), u(t - 1)) : I.right === e.key && (e.preventDefault(), u(t + 1)), k?.(e);
  }, $ = (e) => {
    e.preventDefault();
    const r = e.target, t = e.clipboardData.getData("text/plain"), s = m(r), Y = D(), A = U(Y, X(t), s), O = A.findIndex((_, v) => v > s && _ === ""), F = w(A);
    if (f?.(F), F.length === a) {
      p?.(F), x(a - 1);
      return;
    }
    O !== -1 && x(O), R?.(e);
  };
  return /* @__PURE__ */ C(L, {
    display: "flex",
    gap: "20px",
    alignItems: "center",
    ref: o,
    className: `MuiOtpInput-Box ${g || ""}`,
    ...P,
    children: c.map(({
      character: e,
      inputRef: r
    }, t) => /* @__PURE__ */ C(H, {
      autoFocus: i ? t === 0 : !1,
      autoComplete: "one-time-code",
      value: e,
      inputRef: r,
      className: `MuiOtpInput-TextField MuiOtpInput-TextField-${t + 1} ${M || ""}`,
      onPaste: $,
      onFocus: b,
      onChange: V,
      onKeyDown: j,
      ...E
    }, t))
  });
});
Z.defaultProps = {
  value: "",
  length: 4,
  autoFocus: !1,
  validateChar: () => !0,
  onChange: () => {
  },
  onComplete: () => {
  },
  TextFieldsProps: {}
};
export {
  Z as MuiOtpInput
};
